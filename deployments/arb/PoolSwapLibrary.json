{
    "address": "0xA541A762270bc825F25cDDc0C0a76D8FeB7A2BE4",
    "abi": [
        {
            "inputs": [],
            "name": "MAX_DECIMALS",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "components": [
                        {
                            "internalType": "int256",
                            "name": "oldPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "int256",
                            "name": "newPrice",
                            "type": "int256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "longBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "uint256",
                            "name": "shortBalance",
                            "type": "uint256"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "leverageAmount",
                            "type": "bytes16"
                        },
                        {
                            "internalType": "bytes16",
                            "name": "fee",
                            "type": "bytes16"
                        }
                    ],
                    "internalType": "struct PoolSwapLibrary.PriceChangeData",
                    "name": "priceChange",
                    "type": "tuple"
                }
            ],
            "name": "calculatePriceChange",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "x",
                    "type": "bytes16"
                },
                {
                    "internalType": "bytes16",
                    "name": "y",
                    "type": "bytes16"
                }
            ],
            "name": "compareDecimals",
            "outputs": [
                {
                    "internalType": "int8",
                    "name": "",
                    "type": "int8"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                }
            ],
            "name": "convertDecimalToUInt",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "amount",
                    "type": "uint256"
                }
            ],
            "name": "convertUIntToDecimal",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "int256",
                    "name": "a",
                    "type": "int256"
                },
                {
                    "internalType": "int256",
                    "name": "b",
                    "type": "int256"
                }
            ],
            "name": "divInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_wadValue",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_decimals",
                    "type": "uint256"
                }
            ],
            "name": "fromWad",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "reward",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shortBalance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "longBalance",
                    "type": "uint256"
                }
            ],
            "name": "getBalancesAfterFees",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "lossMultiplier",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                }
            ],
            "name": "getLossAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "ratio",
                    "type": "bytes16"
                },
                {
                    "internalType": "int8",
                    "name": "direction",
                    "type": "int8"
                },
                {
                    "internalType": "bytes16",
                    "name": "leverage",
                    "type": "bytes16"
                }
            ],
            "name": "getLossMultiplier",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shadowBalance",
                    "type": "uint256"
                }
            ],
            "name": "getMintAmount",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "_numerator",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "_denominator",
                    "type": "uint256"
                }
            ],
            "name": "getRatio",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "tokenSupply",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "amountIn",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "balance",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "shadowBalance",
                    "type": "uint256"
                }
            ],
            "name": "getWithdrawAmountOnBurn",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "uint256",
                    "name": "subjectTime",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "lastPriceTimestamp",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "updateInterval",
                    "type": "uint256"
                },
                {
                    "internalType": "uint256",
                    "name": "frontRunningInterval",
                    "type": "uint256"
                }
            ],
            "name": "isBeforeFrontRunningInterval",
            "outputs": [
                {
                    "internalType": "bool",
                    "name": "",
                    "type": "bool"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [
                {
                    "internalType": "bytes16",
                    "name": "a",
                    "type": "bytes16"
                },
                {
                    "internalType": "uint256",
                    "name": "b",
                    "type": "uint256"
                }
            ],
            "name": "multiplyDecimalByUInt",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "pure",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "one",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "zero",
            "outputs": [
                {
                    "internalType": "bytes16",
                    "name": "",
                    "type": "bytes16"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ],
    "transactionHash": "0x313524229256d23d1aeb675c05c3598d11954b0610ae7921919387a6b3961b22",
    "receipt": {
        "to": null,
        "from": "0xfb59B91646cd0890F3E5343384FEb746989B66C7",
        "contractAddress": "0xA541A762270bc825F25cDDc0C0a76D8FeB7A2BE4",
        "transactionIndex": 0,
        "gasUsed": "89371335",
        "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "blockHash": "0xb3a6ce146ff54f095ff0610f8cd11b4aacf5b184555e8166122fa429194a112d",
        "transactionHash": "0x313524229256d23d1aeb675c05c3598d11954b0610ae7921919387a6b3961b22",
        "logs": [],
        "blockNumber": 863744,
        "cumulativeGasUsed": "70215095",
        "status": 1,
        "byzantium": true
    },
    "args": [],
    "solcInputHash": "064a46e8a39a75e0d8a373ad538a65bf",
    "metadata": "{\"compiler\":{\"version\":\"0.8.7+commit.e28d00a7\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MAX_DECIMALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256\",\"name\":\"oldPrice\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"newPrice\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"leverageAmount\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"fee\",\"type\":\"bytes16\"}],\"internalType\":\"struct PoolSwapLibrary.PriceChangeData\",\"name\":\"priceChange\",\"type\":\"tuple\"}],\"name\":\"calculatePriceChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"x\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"y\",\"type\":\"bytes16\"}],\"name\":\"compareDecimals\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"}],\"name\":\"convertDecimalToUInt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"convertUIntToDecimal\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"b\",\"type\":\"int256\"}],\"name\":\"divInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wadValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"fromWad\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"longBalance\",\"type\":\"uint256\"}],\"name\":\"getBalancesAfterFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"lossMultiplier\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"getLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"ratio\",\"type\":\"bytes16\"},{\"internalType\":\"int8\",\"name\":\"direction\",\"type\":\"int8\"},{\"internalType\":\"bytes16\",\"name\":\"leverage\",\"type\":\"bytes16\"}],\"name\":\"getLossMultiplier\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getMintAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"getRatio\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shadowBalance\",\"type\":\"uint256\"}],\"name\":\"getWithdrawAmountOnBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"subjectTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPriceTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frontRunningInterval\",\"type\":\"uint256\"}],\"name\":\"isBeforeFrontRunningInterval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"a\",\"type\":\"bytes16\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"multiplyDecimalByUInt\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"one\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zero\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"details\":\"This function should be called by the LeveragedPool.\",\"params\":{\"priceChange\":\"The struct containing necessary data to calculate price change\"}},\"compareDecimals(bytes16,bytes16)\":{\"params\":{\"x\":\"The first number to compare\",\"y\":\"The second number to compare\"},\"returns\":{\"_0\":\"-1 if x < y, 0 if x = y, or 1 if x > y\"}},\"convertDecimalToUInt(bytes16)\":{\"params\":{\"ratio\":\"The value to convert\"},\"returns\":{\"_0\":\"The converted value\"}},\"convertUIntToDecimal(uint256)\":{\"params\":{\"amount\":\"The amount to convert\"},\"returns\":{\"_0\":\"The amount as a IEEE754 quadruple precision number\"}},\"divInt(int256,int256)\":{\"params\":{\"a\":\"The dividend\",\"b\":\"The divisor\"},\"returns\":{\"_0\":\"The quotient\"}},\"fromWad(uint256,uint256)\":{\"returns\":{\"_0\":\"Converted non-WAD value\"}},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"details\":\"Assumes shortBalance + longBalance >= reward\",\"params\":{\"longBalance\":\"Long balance of the pool\",\"reward\":\"Amount of keeper reward\",\"shortBalance\":\"Short balance of the pool\"},\"returns\":{\"_0\":\"shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\",\"_1\":\"longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\"}},\"getLossAmount(bytes16,uint256)\":{\"params\":{\"balance\":\"The balance of the losing pool\",\"lossMultiplier\":\"The multiplier to use\"}},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"params\":{\"direction\":\"The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\",\"leverage\":\"The amount of leverage to apply\",\"ratio\":\"The ratio of new price to old price\"},\"returns\":{\"_0\":\"The multiplier\"}},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculated as (tokenSupply + shadowBalance) * amountIn / balance\",\"params\":{\"amountIn\":\"Commitment amount of collateral tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of pool tokens to be minted\"}},\"getRatio(uint256,uint256)\":{\"details\":\"Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\",\"params\":{\"_denominator\":\"The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\",\"_numerator\":\"The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\"},\"returns\":{\"_0\":\"the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\"}},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"details\":\"Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\",\"params\":{\"amountIn\":\"Commitment amount of collateral tokens going into the pool\",\"balance\":\"Balance of the pool (no. of underlying collateral tokens in pool)\",\"shadowBalance\":\"Balance the shadow pool at time of mint\",\"tokenSupply\":\"Total supply of pool tokens\"},\"returns\":{\"_0\":\"Number of settlement tokens to be withdrawn on a burn\"}},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"details\":\"If you try to uncommit AFTER the frontRunningInterval, it should revert.\",\"params\":{\"frontRunningInterval\":\"The window of time before a price udpate users can not uncommit or have their commit executed from\",\"lastPriceTimestamp\":\"The timestamp of the last price update\",\"subjectTime\":\"The timestamp for which you want to calculate if it was beforeFrontRunningInterval\",\"updateInterval\":\"The interval between price updates\"}},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"params\":{\"a\":\"The first term\",\"b\":\"The second term\"},\"returns\":{\"_0\":\"The product of a*b as a decimal\"}}},\"title\":\"Library for various useful (mostly) mathematical functions\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculatePriceChange(PoolSwapLibrary.PriceChangeData)\":{\"notice\":\"Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\"},\"compareDecimals(bytes16,bytes16)\":{\"notice\":\"Compares two decimal numbers\"},\"convertDecimalToUInt(bytes16)\":{\"notice\":\"Converts a raw decimal value to a more readable uint256 value\"},\"convertUIntToDecimal(uint256)\":{\"notice\":\"Converts an integer value to a compatible decimal value\"},\"divInt(int256,int256)\":{\"notice\":\"Divides two integers\"},\"fromWad(uint256,uint256)\":{\"notice\":\"Converts from a WAD to normal value\"},\"getBalancesAfterFees(uint256,uint256,uint256)\":{\"notice\":\"Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool\"},\"getLossAmount(bytes16,uint256)\":{\"notice\":\"Calculates the amount to take from the losing pool\"},\"getLossMultiplier(bytes16,int8,bytes16)\":{\"notice\":\"Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\"},\"getMintAmount(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of pool tokens to be minted based on existing tokens\"},\"getRatio(uint256,uint256)\":{\"notice\":\"Calculates the ratio between two numbers\"},\"getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\"},\"isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)\":{\"notice\":\"Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment.\"},\"multiplyDecimalByUInt(bytes16,uint256)\":{\"notice\":\"Multiplies a decimal and an unsigned integer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolSwapLibrary.sol\":\"PoolSwapLibrary\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolSwapLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title Library for various useful (mostly) mathematical functions\\nlibrary PoolSwapLibrary {\\n    bytes16 public constant one = 0x3fff0000000000000000000000000000;\\n    bytes16 public constant zero = 0x00000000000000000000000000000000;\\n\\n    /* ABDKMathQuad defines this but it's private */\\n    bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n    uint256 public constant MAX_DECIMALS = 18;\\n\\n    struct PriceChangeData {\\n        int256 oldPrice;\\n        int256 newPrice;\\n        uint256 longBalance;\\n        uint256 shortBalance;\\n        bytes16 leverageAmount;\\n        bytes16 fee;\\n    }\\n\\n    /**\\n     * @notice Calculates the ratio between two numbers\\n     * @dev Rounds any overflow towards 0. If either parameter is zero, the ratio is 0\\n     * @param _numerator The \\\"parts per\\\" side of the equation. If this is zero, the ratio is zero\\n     * @param _denominator The \\\"per part\\\" side of the equation. If this is zero, the ratio is zero\\n     * @return the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)\\n     */\\n    function getRatio(uint256 _numerator, uint256 _denominator) public pure returns (bytes16) {\\n        // Catch the divide by zero error.\\n        if (_denominator == 0) {\\n            return 0;\\n        }\\n        return ABDKMathQuad.div(ABDKMathQuad.fromUInt(_numerator), ABDKMathQuad.fromUInt(_denominator));\\n    }\\n\\n    /**\\n     * @notice Gets the short and long balances after the keeper rewards have been paid out\\n     *         Keeper rewards are paid proportionally to the short and long pool\\n     * @dev Assumes shortBalance + longBalance >= reward\\n     * @param reward Amount of keeper reward\\n     * @param shortBalance Short balance of the pool\\n     * @param longBalance Long balance of the pool\\n     * @return shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid\\n     * @return longBalanceAfterFees Long balance of the pool after the keeper reward has been paid\\n     */\\n    function getBalancesAfterFees(\\n        uint256 reward,\\n        uint256 shortBalance,\\n        uint256 longBalance\\n    ) external pure returns (uint256, uint256) {\\n        bytes16 ratioShort = getRatio(shortBalance, shortBalance + longBalance);\\n\\n        uint256 shortFees = convertDecimalToUInt(multiplyDecimalByUInt(ratioShort, reward));\\n\\n        uint256 shortBalanceAfterFees = shortBalance - shortFees;\\n        uint256 longBalanceAfterFees = longBalance - (reward - shortFees);\\n\\n        // Return shortBalance and longBalance after rewards are paid out\\n        return (shortBalanceAfterFees, longBalanceAfterFees);\\n    }\\n\\n    /**\\n     * @notice Compares two decimal numbers\\n     * @param x The first number to compare\\n     * @param y The second number to compare\\n     * @return -1 if x < y, 0 if x = y, or 1 if x > y\\n     */\\n    function compareDecimals(bytes16 x, bytes16 y) public pure returns (int8) {\\n        return ABDKMathQuad.cmp(x, y);\\n    }\\n\\n    /**\\n     * @notice Converts an integer value to a compatible decimal value\\n     * @param amount The amount to convert\\n     * @return The amount as a IEEE754 quadruple precision number\\n     */\\n    function convertUIntToDecimal(uint256 amount) external pure returns (bytes16) {\\n        return ABDKMathQuad.fromUInt(amount);\\n    }\\n\\n    /**\\n     * @notice Converts a raw decimal value to a more readable uint256 value\\n     * @param ratio The value to convert\\n     * @return The converted value\\n     */\\n    function convertDecimalToUInt(bytes16 ratio) public pure returns (uint256) {\\n        return ABDKMathQuad.toUInt(ratio);\\n    }\\n\\n    /**\\n     * @notice Multiplies a decimal and an unsigned integer\\n     * @param a The first term\\n     * @param b The second term\\n     * @return The product of a*b as a decimal\\n     */\\n    function multiplyDecimalByUInt(bytes16 a, uint256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.mul(a, ABDKMathQuad.fromUInt(b));\\n    }\\n\\n    /**\\n     * @notice Divides two integers\\n     * @param a The dividend\\n     * @param b The divisor\\n     * @return The quotient\\n     */\\n    function divInt(int256 a, int256 b) public pure returns (bytes16) {\\n        return ABDKMathQuad.div(ABDKMathQuad.fromInt(a), ABDKMathQuad.fromInt(b));\\n    }\\n\\n    /**\\n     * @notice Calculates the loss multiplier to apply to the losing pool. Includes the power leverage\\n     * @param ratio The ratio of new price to old price\\n     * @param direction The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased\\n     * @param leverage The amount of leverage to apply\\n     * @return The multiplier\\n     */\\n    function getLossMultiplier(\\n        bytes16 ratio,\\n        int8 direction,\\n        bytes16 leverage\\n    ) public pure returns (bytes16) {\\n        // If decreased:  2 ^ (leverage * log2[(1 * new/old) + [(0 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2[(new/old)])\\n        // If increased:  2 ^ (leverage * log2[(0 * new/old) + [(1 * 1) / new/old]])\\n        //              = 2 ^ (leverage * log2([1 / new/old]))\\n        //              = 2 ^ (leverage * log2([old/new]))\\n        return\\n            ABDKMathQuad.pow_2(\\n                ABDKMathQuad.mul(leverage, ABDKMathQuad.log_2(direction < 0 ? ratio : ABDKMathQuad.div(one, ratio)))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the amount to take from the losing pool\\n     * @param lossMultiplier The multiplier to use\\n     * @param balance The balance of the losing pool\\n     */\\n    function getLossAmount(bytes16 lossMultiplier, uint256 balance) public pure returns (uint256) {\\n        return\\n            ABDKMathQuad.toUInt(\\n                ABDKMathQuad.mul(ABDKMathQuad.sub(one, lossMultiplier), ABDKMathQuad.fromUInt(balance))\\n            );\\n    }\\n\\n    /**\\n     * @notice Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other.\\n     * @dev This function should be called by the LeveragedPool.\\n     * @param priceChange The struct containing necessary data to calculate price change\\n     */\\n    function calculatePriceChange(PriceChangeData memory priceChange)\\n        external\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 shortBalance = priceChange.shortBalance;\\n        uint256 longBalance = priceChange.longBalance;\\n        bytes16 leverageAmount = priceChange.leverageAmount;\\n        int256 oldPrice = priceChange.oldPrice;\\n        int256 newPrice = priceChange.newPrice;\\n        bytes16 fee = priceChange.fee;\\n\\n        // Calculate fees from long and short sides\\n        uint256 longFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, longBalance));\\n        uint256 shortFeeAmount = convertDecimalToUInt(multiplyDecimalByUInt(fee, shortBalance));\\n        uint256 totalFeeAmount = 0;\\n\\n        // fee is enforced to be < 1.\\n        // Therefore, shortFeeAmount < shortBalance, and longFeeAmount < longBalance\\n        shortBalance = shortBalance - shortFeeAmount;\\n        longBalance = longBalance - longFeeAmount;\\n        totalFeeAmount = totalFeeAmount + shortFeeAmount + longFeeAmount;\\n\\n        // Use the ratio to determine if the price increased or decreased and therefore which direction\\n        // the funds should be transferred towards.\\n\\n        bytes16 ratio = divInt(newPrice, oldPrice);\\n        int8 direction = compareDecimals(ratio, PoolSwapLibrary.one);\\n        // Take into account the leverage\\n        bytes16 lossMultiplier = getLossMultiplier(ratio, direction, leverageAmount);\\n\\n        if (direction >= 0 && shortBalance > 0) {\\n            // Move funds from short to long pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, shortBalance);\\n            shortBalance = shortBalance - lossAmount;\\n            longBalance = longBalance + lossAmount;\\n        } else if (direction < 0 && longBalance > 0) {\\n            // Move funds from long to short pair\\n            uint256 lossAmount = getLossAmount(lossMultiplier, longBalance);\\n            shortBalance = shortBalance + lossAmount;\\n            longBalance = longBalance - lossAmount;\\n        }\\n\\n        return (longBalance, shortBalance, totalFeeAmount);\\n    }\\n\\n    /**\\n     * @notice Returns true if the given timestamp is BEFORE the frontRunningInterval starts,\\n     *         which is allowed for uncommitment.\\n     * @dev If you try to uncommit AFTER the frontRunningInterval, it should revert.\\n     * @param subjectTime The timestamp for which you want to calculate if it was beforeFrontRunningInterval\\n     * @param lastPriceTimestamp The timestamp of the last price update\\n     * @param updateInterval The interval between price updates\\n     * @param frontRunningInterval The window of time before a price udpate users can not uncommit or have their commit executed from\\n     */\\n    function isBeforeFrontRunningInterval(\\n        uint256 subjectTime,\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 frontRunningInterval\\n    ) external pure returns (bool) {\\n        return lastPriceTimestamp + updateInterval - frontRunningInterval > subjectTime;\\n    }\\n\\n    /**\\n     * @notice Gets the number of settlement tokens to be withdrawn based on a pool token burn amount\\n     * @dev Calculates as `balance * amountIn / (tokenSupply + shadowBalance)\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of settlement tokens to be withdrawn on a burn\\n     */\\n    function getWithdrawAmountOnBurn(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        require(amountIn > 0, \\\"Invalid amount\\\");\\n\\n        // Catch the divide by zero error.\\n        if (balance == 0 || tokenSupply + shadowBalance == 0) {\\n            return amountIn;\\n        }\\n        bytes16 numerator = ABDKMathQuad.mul(ABDKMathQuad.fromUInt(balance), ABDKMathQuad.fromUInt(amountIn));\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(tokenSupply + shadowBalance)));\\n    }\\n\\n    /**\\n     * @notice Gets the number of pool tokens to be minted based on existing tokens\\n     * @dev Calculated as (tokenSupply + shadowBalance) * amountIn / balance\\n     * @param tokenSupply Total supply of pool tokens\\n     * @param amountIn Commitment amount of collateral tokens going into the pool\\n     * @param balance Balance of the pool (no. of underlying collateral tokens in pool)\\n     * @param shadowBalance Balance the shadow pool at time of mint\\n     * @return Number of pool tokens to be minted\\n     */\\n    function getMintAmount(\\n        uint256 tokenSupply,\\n        uint256 amountIn,\\n        uint256 balance,\\n        uint256 shadowBalance\\n    ) external pure returns (uint256) {\\n        require(amountIn > 0, \\\"Invalid amount\\\");\\n\\n        // Catch the divide by zero error.\\n        if (balance == 0 || tokenSupply + shadowBalance == 0) {\\n            return amountIn;\\n        }\\n\\n        bytes16 numerator = ABDKMathQuad.mul(\\n            ABDKMathQuad.fromUInt(tokenSupply + shadowBalance),\\n            ABDKMathQuad.fromUInt(amountIn)\\n        );\\n        return ABDKMathQuad.toUInt(ABDKMathQuad.div(numerator, ABDKMathQuad.fromUInt(balance)));\\n    }\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(uint256 _wadValue, uint256 _decimals) external pure returns (uint256) {\\n        uint256 scaler = 10**(MAX_DECIMALS - _decimals);\\n        return _wadValue / scaler;\\n    }\\n}\\n\",\"keccak256\":\"0x59214f98b2920633aa86ef48665dde4c57f059a234df3ef635ae89ba9d7dd5a1\",\"license\":\"MIT\"}},\"version\":1}",
    "bytecode": "0x612b8f61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101155760003560e01c8063ab41556f116100ac578063c3ff80911161007b578063c3ff80911461024b578063cff700011461025e578063dc35bc1314610271578063debb52df14610299578063dfdbe4da146102ac57600080fd5b8063ab41556f1461020a578063aeb64d7d1461021d578063bc1b392d14610230578063bf36f0e91461023857600080fd5b806381a799db116100e857806381a799db1461019a578063901717d1146101bd578063a481c1b4146101c9578063a818c0d2146101f757600080fd5b80630417cf8e1461011a5780631842c9d814610135578063202f12571461015b578063422051e714610187575b600080fd5b610122601281565b6040519081526020015b60405180910390f35b610148610143366004612807565b6102bf565b60405160009190910b815260200161012c565b61016e6101693660046128af565b6102d4565b6040516001600160801b0319909116815260200161012c565b61016e610195366004612885565b6102f0565b6101ad6101a83660046129a9565b610304565b604051901515815260200161012c565b61016e613fff60f01b81565b6101dc6101d73660046128d1565b610328565b6040805193845260208401929092529082015260600161012c565b610122610205366004612885565b610471565b6101226102183660046129a9565b610496565b61012261022b3660046127ec565b610539565b61016e600081565b6101226102463660046128af565b610544565b61016e61025936600461283a565b610569565b61016e61026c3660046128af565b61059f565b61028461027f36600461297d565b6105c3565b6040805192835260208301919091520161012c565b6101226102a73660046129a9565b61061c565b61016e6102ba366004612964565b6106a2565b60006102cb83836106ad565b90505b92915050565b60006102cb6102e2846107d4565b6102eb846107d4565b610867565b60006102cb836102ff84610b1e565b610b82565b6000848261031285876129db565b61031c9190612b00565b1190505b949350505050565b6060810151604082015160808301518351602085015160a0860151600095869586959194909391929091908661036161022b83886102f0565b9050600061037261022b848a6102f0565b90506000610380828a612b00565b985061038c8389612b00565b97508261039983836129db565b6103a391906129db565b905060006103b186886102d4565b905060006103c482613fff60f01b6102bf565b905060006103d383838c610569565b905060008260000b121580156103e9575060008c115b1561041a5760006103fa828e610471565b9050610406818e612b00565b9c50610412818d6129db565b9b505061045a565b60008260000b12801561042d575060008b115b1561045a57600061043e828d610471565b905061044a818e6129db565b9c50610456818d612b00565b9b50505b50989e999d50909b50979950505050505050505050565b60006102cb610491610488613fff60f01b86610ddd565b6102ff85610b1e565b610def565b60008084116104dd5760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b60448201526064015b60405180910390fd5b8215806104f157506104ef82866129db565b155b156104fd575082610320565b600061051d61051461050f85896129db565b610b1e565b6102ff87610b1e565b905061052f610491826102eb87610b1e565b9695505050505050565b60006102ce82610def565b600080610552836012612b00565b61055d90600a612a58565b905061032081856129f3565b600061032061059a836102ff60008760000b126105945761058f613fff60f01b89610867565b610e73565b87610e73565b611023565b6000816105ae575060006102ce565b6102cb6105ba84610b1e565b6102eb84610b1e565b600080806105d58561026c86826129db565b905060006105e661022b83896102f0565b905060006105f48288612b00565b90506000610602838a612b00565b61060c9088612b00565b9199919850909650505050505050565b600080841161065e5760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b60448201526064016104d4565b821580610672575061067082866129db565b155b1561067e575082610320565b600061068c61051485610b1e565b905061052f610491826102eb61050f878b6129db565b60006102ce82610b1e565b600060016001607f1b03608084901c16617fff60701b8111156106cf57600080fd5b60016001607f1b03608084901c16617fff60701b8111156106ef57600080fd5b6001600160801b03198581169085161415806107185750617fff60701b826001600160801b0316105b61072157600080fd5b6001600160801b03198581169085161415610741576000925050506102ce565b6001607f1b608086811c82118015929187901c91909110159061079357801561078457826001600160801b0316846001600160801b031611610784576001610788565b6000195b9450505050506102ce565b80156107a65760019450505050506102ce565b826001600160801b0316846001600160801b0316116107c757600019610788565b60019450505050506102ce565b6000816107e357506000919050565b60008083136107f557826000036107f7565b825b9050600061080482612376565b9050607081101561081d578060700382901b9150610830565b6070811115610830576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610858576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c8116908214156108ad5780617fff141561089c575061ffff60ef1b91506102ce9050565b505050600160ff1b811682186102ce565b80617fff14156108f1576dffffffffffffffffffffffffffff60801b8416156108e0575061ffff60ef1b91506102ce9050565b505050808218600160ff1b166102ce565b600160801b600160ff1b03841661093b57600160801b600160ff1b038516610923575061ffff60ef1b91506102ce9050565b505050808218600160ff1b16617fff60f01b176102ce565b6001600160701b03608085901c1681610957576001915061095e565b600160701b175b6001600160701b03608087901c168361099d57801561099857600061098282612376565b6001955060e20393840160711901939190911b90505b6109a7565b600160701b1760721b5b8181816109b6576109b6612b43565b049050806109e257600160ff1b878718166109d2576000610788565b600160ff1b9450505050506102ce565b6001606c1b8110156109f6576109f6612b17565b6000600160731b821015610a3557600160721b821015610a2a57600160711b821015610a23576070610a2d565b6071610a2d565b60725b60ff16610a3e565b610a3e82612376565b905083614071018186011115610a5c57617fff945060009150610aef565b83818601613ffc011015610a77576000945060009150610aef565b83818601613f8c011015610ac4578385613ffc011115610aa2578385613ffc010382901b9150610abb565b8385613ffc011015610abb57613ffc8585030382901c91505b60009450610aef565b6070811115610ad7576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102ce565b600081610b2d57506000919050565b816000610b3982612376565b90506070811015610b52578060700382901b9150610b65565b6070811115610b65576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c811690821415610c215780617fff1415610c00576001600160801b03198581169085161415610bcd57505050600160ff1b811682186102ce565b600160ff1b6001600160801b0319868618161415610bf0575050508181176102ce565b5061ffff60ef1b91506102ce9050565b600160801b600160ff1b03841661089c575061ffff60ef1b91506102ce9050565b80617fff1415610c5d57600160801b600160ff1b038516610c4c575061ffff60ef1b91506102ce9050565b505050600160ff1b821681186102ce565b6001600160701b03608086901c1682610c795760019250610c80565b600160701b175b6001600160701b03608086901c1682610c9c5760019250610ca3565b600160701b175b9081029081610cc057600160ff1b878718166109d2576000610788565b928201926000600160e11b831015610cf357600160e01b831015610cec57610ce783612376565b610cf6565b60e0610cf6565b60e15b90506140708186011015610d11576000945060009250610dae565b6140e08186011015610d5457614070851015610d3657846140700383901c9250610d4b565b614070851115610d4b57614070850383901b92505b60009450610dae565b61c0dd8186011115610d6e57617fff945060009250610dae565b6070811115610d85576070810383901c9250610d98565b6070811015610d98578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102ce565b60006102cb83600160ff1b8418612414565b6000617fff60f083901c16613fff811015610e0d5750600092915050565b6001607f1b608084901c10610e2157600080fd5b6140fe811115610e3057600080fd5b600160701b6001600160701b03608085901c161761406f821015610e5a5761406f8290031c610e6c565b61406f821115610e6c5761406e1982011b5b9392505050565b60006001607f1b608083901c1115610e91575061ffff60ef1b919050565b613fff60f01b6001600160801b031983161415610eb057506000919050565b617fff60f083901c811690811415610ec9575090919050565b6001600160701b03608084901c1681610ee55760019150610eec565b600160701b175b80610f0257506001600160f01b03199392505050565b600061406f81613fff8510610f285750600f9290921b9160009150613ffe198401610f67565b60019250600160701b8410610f4a5784613ffe039050600f84901b9350610f67565b6000610f5585612376565b607f8190039590951b9461406d039150505b836001607f1b1415610f9b578215610f7d576001015b6000610f8882612376565b60700392839003929190911b9050610fe9565b600083610fa9576000610fac565b60015b60ff1690505b600160701b821015610fe75793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190610fb2565b505b806001600160701b0316607083901b8461100457600061100a565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561105557508015155b15611069575061ffff60ef1b949350505050565b61400d82111561108f578261108357617fff60f01b611086565b60005b95945050505050565b613f7f8210156110a85750613fff60f01b949350505050565b816110b657600191506110bd565b600160701b175b613fef8211156110d357613fee1982011b6110e5565b613fef8210156110e557613fef8290031c5b8280156110f6575061203760811b81115b1561110657506000949350505050565b821580156111255750713fffffffffffffffffffffffffffffffffff81115b156111395750617fff60f01b949350505050565b6001600160801b0381169060801c83801561115357508115155b1561115f579019906001015b6001607f1b828116156111835770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b8316156111a6577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156111c9577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156111ec5770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b83161561120f577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561123257700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156112555770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561127857700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b83161561129b5770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b8316156112be577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b8316156112e157700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611304577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561132757700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b83161561134a5770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b83161561136d577001000162e525ee054754457d59952920260260801c5b600160701b8316156113905770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b8316156113b3577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b8316156113d657700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156113f95770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b83161561141c57700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b83161561143f5770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611462577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561148557700100000162e430e5a18f6119e3c02282a50260801c5b600160681b8316156114a8577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b8316156114cb57700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156114ee5770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611511577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156115345770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611557577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b83161561157a57700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b83161561159d5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b8316156115c057700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b8316156115e35770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611606577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b83161561162957700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b83161561164c577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b83161561166f57700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b8316156116925770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b8316156116b5577001000000000162e42fefa494f1478fde050260801c5b600160581b8316156116d85770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b8316156116fb577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561171e57700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156117415770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561176457700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156117875770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156117aa577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b8316156117cd57700100000000000162e42fefa39fe95583c20260801c5b600160501b8316156117f0577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561181957700100000000000058b90bfbe8e7cc35c3f00260801c5b69400000000000000000008316156118425770010000000000002c5c85fdf473e242ea380260801c5b692000000000000000000083161561186b577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156118945770010000000000000b17217f7d1cf7d83c1a0260801c5b69080000000000000000008316156118bd577001000000000000058b90bfbe8e7bdcbe2e0260801c5b69040000000000000000008316156118e657700100000000000002c5c85fdf473dea871f0260801c5b690200000000000000000083161561190f5770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561193857700100000000000000b17217f7d1cf79e9490260801c5b688000000000000000008316156119605770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611988577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156119b057700100000000000000162e42fefa39ef366f0260801c5b681000000000000000008316156119d8577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611a0057700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611a285770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611a50577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611a735770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611a9a577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611ac157700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611ae85770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611b0f57700100000000000000000b17217f7d1cf7990260801c5b670800000000000000831615611b365770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615611b5d577001000000000000000002c5c85fdf473de50260801c5b670200000000000000831615611b8457700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615611bab577001000000000000000000b17217f7d1cf780260801c5b6680000000000000831615611bd157700100000000000000000058b90bfbe8e7bb0260801c5b6640000000000000831615611bf75770010000000000000000002c5c85fdf473dd0260801c5b6620000000000000831615611c1d577001000000000000000000162e42fefa39ee0260801c5b6610000000000000831615611c435770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615611c69577001000000000000000000058b90bfbe8e7a0260801c5b6604000000000000831615611c8f57700100000000000000000002c5c85fdf473c0260801c5b6602000000000000831615611cb55770010000000000000000000162e42fefa39d0260801c5b6601000000000000831615611cdb57700100000000000000000000b17217f7d1ce0260801c5b65800000000000831615611d005770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615611d25577001000000000000000000002c5c85fdf4720260801c5b65200000000000831615611d4a57700100000000000000000000162e42fefa380260801c5b65100000000000831615611d6f577001000000000000000000000b17217f7d1b0260801c5b65080000000000831615611d9457700100000000000000000000058b90bfbe8d0260801c5b65040000000000831615611db95770010000000000000000000002c5c85fdf460260801c5b65020000000000831615611dde577001000000000000000000000162e42fefa20260801c5b65010000000000831615611e035770010000000000000000000000b17217f7d00260801c5b648000000000831615611e27577001000000000000000000000058b90bfbe70260801c5b644000000000831615611e4b57700100000000000000000000002c5c85fdf30260801c5b642000000000831615611e6f5770010000000000000000000000162e42fef90260801c5b641000000000831615611e9357700100000000000000000000000b17217f7c0260801c5b640800000000831615611eb75770010000000000000000000000058b90bfbd0260801c5b640400000000831615611edb577001000000000000000000000002c5c85fde0260801c5b640200000000831615611eff57700100000000000000000000000162e42fee0260801c5b640100000000831615611f23577001000000000000000000000000b17217f60260801c5b6380000000831615611f4657700100000000000000000000000058b90bfa0260801c5b6340000000831615611f695770010000000000000000000000002c5c85fc0260801c5b6320000000831615611f8c577001000000000000000000000000162e42fd0260801c5b6310000000831615611faf5770010000000000000000000000000b17217e0260801c5b6308000000831615611fd2577001000000000000000000000000058b90be0260801c5b6304000000831615611ff557700100000000000000000000000002c5c85e0260801c5b63020000008316156120185770010000000000000000000000000162e42e0260801c5b630100000083161561203b57700100000000000000000000000000b172160260801c5b6280000083161561205d5770010000000000000000000000000058b90a0260801c5b6240000083161561207f577001000000000000000000000000002c5c840260801c5b622000008316156120a157700100000000000000000000000000162e410260801c5b621000008316156120c3577001000000000000000000000000000b17200260801c5b620800008316156120e557700100000000000000000000000000058b8f0260801c5b620400008316156121075770010000000000000000000000000002c5c70260801c5b62020000831615612129577001000000000000000000000000000162e30260801c5b6201000083161561214b5770010000000000000000000000000000b1710260801c5b61800083161561216c577001000000000000000000000000000058b80260801c5b61400083161561218d57700100000000000000000000000000002c5b0260801c5b6120008316156121ae5770010000000000000000000000000000162d0260801c5b6110008316156121cf57700100000000000000000000000000000b160260801c5b6108008316156121f05770010000000000000000000000000000058a0260801c5b610400831615612211577001000000000000000000000000000002c40260801c5b610200831615612232577001000000000000000000000000000001610260801c5b610100831615612253577001000000000000000000000000000000b00260801c5b6080831615612273577001000000000000000000000000000000570260801c5b60408316156122935770010000000000000000000000000000002b0260801c5b60208316156122b3577001000000000000000000000000000000150260801c5b60108316156122d35770010000000000000000000000000000000a0260801c5b60088316156122f3577001000000000000000000000000000000040260801c5b6004831615612313577001000000000000000000000000000000010260801c5b8461233457600f81901c6001600160701b03169050613fff82019150612363565b613ffe821161235957600f81901c6001600160701b0316905081613fff039150612363565b600091613fee19011c5b60709190911b1760801b95945050505050565b600080821161238457600080fd5b6000600160801b831061239957608092831c92015b600160401b83106123ac57604092831c92015b64010000000083106123c057602092831c92015b6201000083106123d257601092831c92015b61010083106123e357600892831c92015b601083106123f357600492831c92015b6004831061240357600292831c92015b600283106102ce5760010192915050565b6000617fff60f084811c8216919084901c8116908214156124625780617fff1415612458576001600160801b03198581169085161415610bf05784925050506102ce565b84925050506102ce565b80617fff14156124765783925050506102ce565b6001607f1b608086901c90811015906001600160701b03168361249c57600193506124a3565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846124c957600194506124d0565b600160701b175b82612500576001600160801b03198816600160ff1b146124f057876124f3565b60005b96505050505050506102ce565b80612520576001600160801b03198916600160ff1b146124f057886124f3565b848603841515831515141561262b57607081131561254757899750505050505050506102ce565b60008113156125595790811c90612588565b606f1981121561257257889750505050505050506102ce565b6000811215612588578060000384901c93508596505b92810192600160711b84106125a3576001968701969390931c925b86617fff14156125d557846125bd57617fff60f01b6125c7565b6001600160f01b03195b9750505050505050506102ce565b600160701b8410156125ea57600096506125f7565b6001600160701b03841693505b83607088901b8661260957600061260f565b6001607f1b5b6001600160801b0316171760801b9750505050505050506102ce565b600081131561264657600184901b935060018703965061265d565b600081121561265d57600182901b91506001860396505b607081131561266f57600191506126bc565b600181131561268c576001810360018303901c60010191506126bc565b606f1981121561269f57600193506126bc565b6000198112156126bc576001816000030360018503901c60010193505b8184106126cd5781840393506126d6565b83820393508294505b836126ec5750600096506102ce95505050505050565b60006126f785612376565b9050806071141561271d57600185901c6001600160701b0316945060018801975061276c565b607081101561275f5760708190038089111561274c578086901b6001600160701b031695508089039850612759565b600098600019019590951b945b5061276c565b6001600160701b03851694505b87617fff141561279f578561278657617fff60f01b612790565b6001600160f01b03195b985050505050505050506102ce565b84607089901b876127b15760006127b7565b6001607f1b5b6001600160801b0316171760801b985050505050505050506102ce565b80356001600160801b03198116811461086257600080fd5b6000602082840312156127fe57600080fd5b6102cb826127d4565b6000806040838503121561281a57600080fd5b612823836127d4565b9150612831602084016127d4565b90509250929050565b60008060006060848603121561284f57600080fd5b612858846127d4565b925060208401358060000b811461286e57600080fd5b915061287c604085016127d4565b90509250925092565b6000806040838503121561289857600080fd5b6128a1836127d4565b946020939093013593505050565b600080604083850312156128c257600080fd5b50508035926020909101359150565b600060c082840312156128e357600080fd5b60405160c0810181811067ffffffffffffffff8211171561291457634e487b7160e01b600052604160045260246000fd5b806040525082358152602083013560208201526040830135604082015260608301356060820152612947608084016127d4565b608082015261295860a084016127d4565b60a08201529392505050565b60006020828403121561297657600080fd5b5035919050565b60008060006060848603121561299257600080fd5b505081359360208301359350604090920135919050565b600080600080608085870312156129bf57600080fd5b5050823594602084013594506040840135936060013592509050565b600082198211156129ee576129ee612b2d565b500190565b600082612a1057634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612a50578160001904821115612a3657612a36612b2d565b80851615612a4357918102915b93841c9390800290612a1a565b509250929050565b60006102cb8383600082612a6e575060016102ce565b81612a7b575060006102ce565b8160018114612a915760028114612a9b57612ab7565b60019150506102ce565b60ff841115612aac57612aac612b2d565b50506001821b6102ce565b5060208310610133831016604e8410600b8410161715612ada575081810a6102ce565b612ae48383612a15565b8060001904821115612af857612af8612b2d565b029392505050565b600082821015612b1257612b12612b2d565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212203848f528a301e5dac308d1ed9685320edad08c4822a2c52aee60104d80270e7664736f6c63430008070033",
    "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101155760003560e01c8063ab41556f116100ac578063c3ff80911161007b578063c3ff80911461024b578063cff700011461025e578063dc35bc1314610271578063debb52df14610299578063dfdbe4da146102ac57600080fd5b8063ab41556f1461020a578063aeb64d7d1461021d578063bc1b392d14610230578063bf36f0e91461023857600080fd5b806381a799db116100e857806381a799db1461019a578063901717d1146101bd578063a481c1b4146101c9578063a818c0d2146101f757600080fd5b80630417cf8e1461011a5780631842c9d814610135578063202f12571461015b578063422051e714610187575b600080fd5b610122601281565b6040519081526020015b60405180910390f35b610148610143366004612807565b6102bf565b60405160009190910b815260200161012c565b61016e6101693660046128af565b6102d4565b6040516001600160801b0319909116815260200161012c565b61016e610195366004612885565b6102f0565b6101ad6101a83660046129a9565b610304565b604051901515815260200161012c565b61016e613fff60f01b81565b6101dc6101d73660046128d1565b610328565b6040805193845260208401929092529082015260600161012c565b610122610205366004612885565b610471565b6101226102183660046129a9565b610496565b61012261022b3660046127ec565b610539565b61016e600081565b6101226102463660046128af565b610544565b61016e61025936600461283a565b610569565b61016e61026c3660046128af565b61059f565b61028461027f36600461297d565b6105c3565b6040805192835260208301919091520161012c565b6101226102a73660046129a9565b61061c565b61016e6102ba366004612964565b6106a2565b60006102cb83836106ad565b90505b92915050565b60006102cb6102e2846107d4565b6102eb846107d4565b610867565b60006102cb836102ff84610b1e565b610b82565b6000848261031285876129db565b61031c9190612b00565b1190505b949350505050565b6060810151604082015160808301518351602085015160a0860151600095869586959194909391929091908661036161022b83886102f0565b9050600061037261022b848a6102f0565b90506000610380828a612b00565b985061038c8389612b00565b97508261039983836129db565b6103a391906129db565b905060006103b186886102d4565b905060006103c482613fff60f01b6102bf565b905060006103d383838c610569565b905060008260000b121580156103e9575060008c115b1561041a5760006103fa828e610471565b9050610406818e612b00565b9c50610412818d6129db565b9b505061045a565b60008260000b12801561042d575060008b115b1561045a57600061043e828d610471565b905061044a818e6129db565b9c50610456818d612b00565b9b50505b50989e999d50909b50979950505050505050505050565b60006102cb610491610488613fff60f01b86610ddd565b6102ff85610b1e565b610def565b60008084116104dd5760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b60448201526064015b60405180910390fd5b8215806104f157506104ef82866129db565b155b156104fd575082610320565b600061051d61051461050f85896129db565b610b1e565b6102ff87610b1e565b905061052f610491826102eb87610b1e565b9695505050505050565b60006102ce82610def565b600080610552836012612b00565b61055d90600a612a58565b905061032081856129f3565b600061032061059a836102ff60008760000b126105945761058f613fff60f01b89610867565b610e73565b87610e73565b611023565b6000816105ae575060006102ce565b6102cb6105ba84610b1e565b6102eb84610b1e565b600080806105d58561026c86826129db565b905060006105e661022b83896102f0565b905060006105f48288612b00565b90506000610602838a612b00565b61060c9088612b00565b9199919850909650505050505050565b600080841161065e5760405162461bcd60e51b815260206004820152600e60248201526d125b9d985b1a5908185b5bdd5b9d60921b60448201526064016104d4565b821580610672575061067082866129db565b155b1561067e575082610320565b600061068c61051485610b1e565b905061052f610491826102eb61050f878b6129db565b60006102ce82610b1e565b600060016001607f1b03608084901c16617fff60701b8111156106cf57600080fd5b60016001607f1b03608084901c16617fff60701b8111156106ef57600080fd5b6001600160801b03198581169085161415806107185750617fff60701b826001600160801b0316105b61072157600080fd5b6001600160801b03198581169085161415610741576000925050506102ce565b6001607f1b608086811c82118015929187901c91909110159061079357801561078457826001600160801b0316846001600160801b031611610784576001610788565b6000195b9450505050506102ce565b80156107a65760019450505050506102ce565b826001600160801b0316846001600160801b0316116107c757600019610788565b60019450505050506102ce565b6000816107e357506000919050565b60008083136107f557826000036107f7565b825b9050600061080482612376565b9050607081101561081d578060700382901b9150610830565b6070811115610830576070810382901c91505b6001600160701b03909116613fff820160701b17906000841215610858576001607f1b821791505b5060801b92915050565b919050565b6000617fff60f084811c8216919084901c8116908214156108ad5780617fff141561089c575061ffff60ef1b91506102ce9050565b505050600160ff1b811682186102ce565b80617fff14156108f1576dffffffffffffffffffffffffffff60801b8416156108e0575061ffff60ef1b91506102ce9050565b505050808218600160ff1b166102ce565b600160801b600160ff1b03841661093b57600160801b600160ff1b038516610923575061ffff60ef1b91506102ce9050565b505050808218600160ff1b16617fff60f01b176102ce565b6001600160701b03608085901c1681610957576001915061095e565b600160701b175b6001600160701b03608087901c168361099d57801561099857600061098282612376565b6001955060e20393840160711901939190911b90505b6109a7565b600160701b1760721b5b8181816109b6576109b6612b43565b049050806109e257600160ff1b878718166109d2576000610788565b600160ff1b9450505050506102ce565b6001606c1b8110156109f6576109f6612b17565b6000600160731b821015610a3557600160721b821015610a2a57600160711b821015610a23576070610a2d565b6071610a2d565b60725b60ff16610a3e565b610a3e82612376565b905083614071018186011115610a5c57617fff945060009150610aef565b83818601613ffc011015610a77576000945060009150610aef565b83818601613f8c011015610ac4578385613ffc011115610aa2578385613ffc010382901b9150610abb565b8385613ffc011015610abb57613ffc8585030382901c91505b60009450610aef565b6070811115610ad7576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102ce565b600081610b2d57506000919050565b816000610b3982612376565b90506070811015610b52578060700382901b9150610b65565b6070811115610b65576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c811690821415610c215780617fff1415610c00576001600160801b03198581169085161415610bcd57505050600160ff1b811682186102ce565b600160ff1b6001600160801b0319868618161415610bf0575050508181176102ce565b5061ffff60ef1b91506102ce9050565b600160801b600160ff1b03841661089c575061ffff60ef1b91506102ce9050565b80617fff1415610c5d57600160801b600160ff1b038516610c4c575061ffff60ef1b91506102ce9050565b505050600160ff1b821681186102ce565b6001600160701b03608086901c1682610c795760019250610c80565b600160701b175b6001600160701b03608086901c1682610c9c5760019250610ca3565b600160701b175b9081029081610cc057600160ff1b878718166109d2576000610788565b928201926000600160e11b831015610cf357600160e01b831015610cec57610ce783612376565b610cf6565b60e0610cf6565b60e15b90506140708186011015610d11576000945060009250610dae565b6140e08186011015610d5457614070851015610d3657846140700383901c9250610d4b565b614070851115610d4b57614070850383901b92505b60009450610dae565b61c0dd8186011115610d6e57617fff945060009250610dae565b6070811115610d85576070810383901c9250610d98565b6070811015610d98578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b955050505050506102ce565b60006102cb83600160ff1b8418612414565b6000617fff60f083901c16613fff811015610e0d5750600092915050565b6001607f1b608084901c10610e2157600080fd5b6140fe811115610e3057600080fd5b600160701b6001600160701b03608085901c161761406f821015610e5a5761406f8290031c610e6c565b61406f821115610e6c5761406e1982011b5b9392505050565b60006001607f1b608083901c1115610e91575061ffff60ef1b919050565b613fff60f01b6001600160801b031983161415610eb057506000919050565b617fff60f083901c811690811415610ec9575090919050565b6001600160701b03608084901c1681610ee55760019150610eec565b600160701b175b80610f0257506001600160f01b03199392505050565b600061406f81613fff8510610f285750600f9290921b9160009150613ffe198401610f67565b60019250600160701b8410610f4a5784613ffe039050600f84901b9350610f67565b6000610f5585612376565b607f8190039590951b9461406d039150505b836001607f1b1415610f9b578215610f7d576001015b6000610f8882612376565b60700392839003929190911b9050610fe9565b600083610fa9576000610fac565b60015b60ff1690505b600160701b821015610fe75793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190610fb2565b505b806001600160701b0316607083901b8461100457600061100a565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561105557508015155b15611069575061ffff60ef1b949350505050565b61400d82111561108f578261108357617fff60f01b611086565b60005b95945050505050565b613f7f8210156110a85750613fff60f01b949350505050565b816110b657600191506110bd565b600160701b175b613fef8211156110d357613fee1982011b6110e5565b613fef8210156110e557613fef8290031c5b8280156110f6575061203760811b81115b1561110657506000949350505050565b821580156111255750713fffffffffffffffffffffffffffffffffff81115b156111395750617fff60f01b949350505050565b6001600160801b0381169060801c83801561115357508115155b1561115f579019906001015b6001607f1b828116156111835770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b8316156111a6577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156111c9577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156111ec5770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b83161561120f577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561123257700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156112555770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561127857700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b83161561129b5770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b8316156112be577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b8316156112e157700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b831615611304577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561132757700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b83161561134a5770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b83161561136d577001000162e525ee054754457d59952920260260801c5b600160701b8316156113905770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b8316156113b3577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b8316156113d657700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156113f95770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b83161561141c57700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b83161561143f5770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611462577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561148557700100000162e430e5a18f6119e3c02282a50260801c5b600160681b8316156114a8577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b8316156114cb57700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156114ee5770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611511577001000000162e42fff037df38aa2b219f060260801c5b600160641b8316156115345770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611557577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b83161561157a57700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b83161561159d5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b8316156115c057700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b8316156115e35770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611606577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b83161561162957700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b83161561164c577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b83161561166f57700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b8316156116925770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b8316156116b5577001000000000162e42fefa494f1478fde050260801c5b600160581b8316156116d85770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b8316156116fb577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b83161561171e57700100000000002c5c85fdf477b662b269450260801c5b600160551b8316156117415770010000000000162e42fefa3ae53369388c0260801c5b600160541b83161561176457700100000000000b17217f7d1d351a389d400260801c5b600160531b8316156117875770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b8316156117aa577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b8316156117cd57700100000000000162e42fefa39fe95583c20260801c5b600160501b8316156117f0577001000000000000b17217f7d1cfb72b45e10260801c5b698000000000000000000083161561181957700100000000000058b90bfbe8e7cc35c3f00260801c5b69400000000000000000008316156118425770010000000000002c5c85fdf473e242ea380260801c5b692000000000000000000083161561186b577001000000000000162e42fefa39f02b772c0260801c5b69100000000000000000008316156118945770010000000000000b17217f7d1cf7d83c1a0260801c5b69080000000000000000008316156118bd577001000000000000058b90bfbe8e7bdcbe2e0260801c5b69040000000000000000008316156118e657700100000000000002c5c85fdf473dea871f0260801c5b690200000000000000000083161561190f5770010000000000000162e42fefa39ef44d910260801c5b690100000000000000000083161561193857700100000000000000b17217f7d1cf79e9490260801c5b688000000000000000008316156119605770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611988577001000000000000002c5c85fdf473de6eca0260801c5b682000000000000000008316156119b057700100000000000000162e42fefa39ef366f0260801c5b681000000000000000008316156119d8577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611a0057700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611a285770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611a50577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611a735770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611a9a577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611ac157700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611ae85770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611b0f57700100000000000000000b17217f7d1cf7990260801c5b670800000000000000831615611b365770010000000000000000058b90bfbe8e7bcc0260801c5b670400000000000000831615611b5d577001000000000000000002c5c85fdf473de50260801c5b670200000000000000831615611b8457700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615611bab577001000000000000000000b17217f7d1cf780260801c5b6680000000000000831615611bd157700100000000000000000058b90bfbe8e7bb0260801c5b6640000000000000831615611bf75770010000000000000000002c5c85fdf473dd0260801c5b6620000000000000831615611c1d577001000000000000000000162e42fefa39ee0260801c5b6610000000000000831615611c435770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615611c69577001000000000000000000058b90bfbe8e7a0260801c5b6604000000000000831615611c8f57700100000000000000000002c5c85fdf473c0260801c5b6602000000000000831615611cb55770010000000000000000000162e42fefa39d0260801c5b6601000000000000831615611cdb57700100000000000000000000b17217f7d1ce0260801c5b65800000000000831615611d005770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615611d25577001000000000000000000002c5c85fdf4720260801c5b65200000000000831615611d4a57700100000000000000000000162e42fefa380260801c5b65100000000000831615611d6f577001000000000000000000000b17217f7d1b0260801c5b65080000000000831615611d9457700100000000000000000000058b90bfbe8d0260801c5b65040000000000831615611db95770010000000000000000000002c5c85fdf460260801c5b65020000000000831615611dde577001000000000000000000000162e42fefa20260801c5b65010000000000831615611e035770010000000000000000000000b17217f7d00260801c5b648000000000831615611e27577001000000000000000000000058b90bfbe70260801c5b644000000000831615611e4b57700100000000000000000000002c5c85fdf30260801c5b642000000000831615611e6f5770010000000000000000000000162e42fef90260801c5b641000000000831615611e9357700100000000000000000000000b17217f7c0260801c5b640800000000831615611eb75770010000000000000000000000058b90bfbd0260801c5b640400000000831615611edb577001000000000000000000000002c5c85fde0260801c5b640200000000831615611eff57700100000000000000000000000162e42fee0260801c5b640100000000831615611f23577001000000000000000000000000b17217f60260801c5b6380000000831615611f4657700100000000000000000000000058b90bfa0260801c5b6340000000831615611f695770010000000000000000000000002c5c85fc0260801c5b6320000000831615611f8c577001000000000000000000000000162e42fd0260801c5b6310000000831615611faf5770010000000000000000000000000b17217e0260801c5b6308000000831615611fd2577001000000000000000000000000058b90be0260801c5b6304000000831615611ff557700100000000000000000000000002c5c85e0260801c5b63020000008316156120185770010000000000000000000000000162e42e0260801c5b630100000083161561203b57700100000000000000000000000000b172160260801c5b6280000083161561205d5770010000000000000000000000000058b90a0260801c5b6240000083161561207f577001000000000000000000000000002c5c840260801c5b622000008316156120a157700100000000000000000000000000162e410260801c5b621000008316156120c3577001000000000000000000000000000b17200260801c5b620800008316156120e557700100000000000000000000000000058b8f0260801c5b620400008316156121075770010000000000000000000000000002c5c70260801c5b62020000831615612129577001000000000000000000000000000162e30260801c5b6201000083161561214b5770010000000000000000000000000000b1710260801c5b61800083161561216c577001000000000000000000000000000058b80260801c5b61400083161561218d57700100000000000000000000000000002c5b0260801c5b6120008316156121ae5770010000000000000000000000000000162d0260801c5b6110008316156121cf57700100000000000000000000000000000b160260801c5b6108008316156121f05770010000000000000000000000000000058a0260801c5b610400831615612211577001000000000000000000000000000002c40260801c5b610200831615612232577001000000000000000000000000000001610260801c5b610100831615612253577001000000000000000000000000000000b00260801c5b6080831615612273577001000000000000000000000000000000570260801c5b60408316156122935770010000000000000000000000000000002b0260801c5b60208316156122b3577001000000000000000000000000000000150260801c5b60108316156122d35770010000000000000000000000000000000a0260801c5b60088316156122f3577001000000000000000000000000000000040260801c5b6004831615612313577001000000000000000000000000000000010260801c5b8461233457600f81901c6001600160701b03169050613fff82019150612363565b613ffe821161235957600f81901c6001600160701b0316905081613fff039150612363565b600091613fee19011c5b60709190911b1760801b95945050505050565b600080821161238457600080fd5b6000600160801b831061239957608092831c92015b600160401b83106123ac57604092831c92015b64010000000083106123c057602092831c92015b6201000083106123d257601092831c92015b61010083106123e357600892831c92015b601083106123f357600492831c92015b6004831061240357600292831c92015b600283106102ce5760010192915050565b6000617fff60f084811c8216919084901c8116908214156124625780617fff1415612458576001600160801b03198581169085161415610bf05784925050506102ce565b84925050506102ce565b80617fff14156124765783925050506102ce565b6001607f1b608086901c90811015906001600160701b03168361249c57600193506124a3565b600160701b175b6001607f1b608087901c90811015906001600160701b0316846124c957600194506124d0565b600160701b175b82612500576001600160801b03198816600160ff1b146124f057876124f3565b60005b96505050505050506102ce565b80612520576001600160801b03198916600160ff1b146124f057886124f3565b848603841515831515141561262b57607081131561254757899750505050505050506102ce565b60008113156125595790811c90612588565b606f1981121561257257889750505050505050506102ce565b6000811215612588578060000384901c93508596505b92810192600160711b84106125a3576001968701969390931c925b86617fff14156125d557846125bd57617fff60f01b6125c7565b6001600160f01b03195b9750505050505050506102ce565b600160701b8410156125ea57600096506125f7565b6001600160701b03841693505b83607088901b8661260957600061260f565b6001607f1b5b6001600160801b0316171760801b9750505050505050506102ce565b600081131561264657600184901b935060018703965061265d565b600081121561265d57600182901b91506001860396505b607081131561266f57600191506126bc565b600181131561268c576001810360018303901c60010191506126bc565b606f1981121561269f57600193506126bc565b6000198112156126bc576001816000030360018503901c60010193505b8184106126cd5781840393506126d6565b83820393508294505b836126ec5750600096506102ce95505050505050565b60006126f785612376565b9050806071141561271d57600185901c6001600160701b0316945060018801975061276c565b607081101561275f5760708190038089111561274c578086901b6001600160701b031695508089039850612759565b600098600019019590951b945b5061276c565b6001600160701b03851694505b87617fff141561279f578561278657617fff60f01b612790565b6001600160f01b03195b985050505050505050506102ce565b84607089901b876127b15760006127b7565b6001607f1b5b6001600160801b0316171760801b985050505050505050506102ce565b80356001600160801b03198116811461086257600080fd5b6000602082840312156127fe57600080fd5b6102cb826127d4565b6000806040838503121561281a57600080fd5b612823836127d4565b9150612831602084016127d4565b90509250929050565b60008060006060848603121561284f57600080fd5b612858846127d4565b925060208401358060000b811461286e57600080fd5b915061287c604085016127d4565b90509250925092565b6000806040838503121561289857600080fd5b6128a1836127d4565b946020939093013593505050565b600080604083850312156128c257600080fd5b50508035926020909101359150565b600060c082840312156128e357600080fd5b60405160c0810181811067ffffffffffffffff8211171561291457634e487b7160e01b600052604160045260246000fd5b806040525082358152602083013560208201526040830135604082015260608301356060820152612947608084016127d4565b608082015261295860a084016127d4565b60a08201529392505050565b60006020828403121561297657600080fd5b5035919050565b60008060006060848603121561299257600080fd5b505081359360208301359350604090920135919050565b600080600080608085870312156129bf57600080fd5b5050823594602084013594506040840135936060013592509050565b600082198211156129ee576129ee612b2d565b500190565b600082612a1057634e487b7160e01b600052601260045260246000fd5b500490565b600181815b80851115612a50578160001904821115612a3657612a36612b2d565b80851615612a4357918102915b93841c9390800290612a1a565b509250929050565b60006102cb8383600082612a6e575060016102ce565b81612a7b575060006102ce565b8160018114612a915760028114612a9b57612ab7565b60019150506102ce565b60ff841115612aac57612aac612b2d565b50506001821b6102ce565b5060208310610133831016604e8410600b8410161715612ada575081810a6102ce565b612ae48383612a15565b8060001904821115612af857612af8612b2d565b029392505050565b600082821015612b1257612b12612b2d565b500390565b634e487b7160e01b600052600160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fdfea26469706673582212203848f528a301e5dac308d1ed9685320edad08c4822a2c52aee60104d80270e7664736f6c63430008070033",
    "devdoc": {
        "kind": "dev",
        "methods": {
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "details": "This function should be called by the LeveragedPool.",
                "params": {
                    "priceChange": "The struct containing necessary data to calculate price change"
                }
            },
            "compareDecimals(bytes16,bytes16)": {
                "params": {
                    "x": "The first number to compare",
                    "y": "The second number to compare"
                },
                "returns": {
                    "_0": "-1 if x < y, 0 if x = y, or 1 if x > y"
                }
            },
            "convertDecimalToUInt(bytes16)": {
                "params": {
                    "ratio": "The value to convert"
                },
                "returns": {
                    "_0": "The converted value"
                }
            },
            "convertUIntToDecimal(uint256)": {
                "params": {
                    "amount": "The amount to convert"
                },
                "returns": {
                    "_0": "The amount as a IEEE754 quadruple precision number"
                }
            },
            "divInt(int256,int256)": {
                "params": {
                    "a": "The dividend",
                    "b": "The divisor"
                },
                "returns": {
                    "_0": "The quotient"
                }
            },
            "fromWad(uint256,uint256)": {
                "returns": {
                    "_0": "Converted non-WAD value"
                }
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "details": "Assumes shortBalance + longBalance >= reward",
                "params": {
                    "longBalance": "Long balance of the pool",
                    "reward": "Amount of keeper reward",
                    "shortBalance": "Short balance of the pool"
                },
                "returns": {
                    "_0": "shortBalanceAfterFees Short balance of the pool after the keeper reward has been paid",
                    "_1": "longBalanceAfterFees Long balance of the pool after the keeper reward has been paid"
                }
            },
            "getLossAmount(bytes16,uint256)": {
                "params": {
                    "balance": "The balance of the losing pool",
                    "lossMultiplier": "The multiplier to use"
                }
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "params": {
                    "direction": "The direction of the change. -1 if it's decreased, 0 if it hasn't changed, and 1 if it's increased",
                    "leverage": "The amount of leverage to apply",
                    "ratio": "The ratio of new price to old price"
                },
                "returns": {
                    "_0": "The multiplier"
                }
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "details": "Calculated as (tokenSupply + shadowBalance) * amountIn / balance",
                "params": {
                    "amountIn": "Commitment amount of collateral tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
                    "shadowBalance": "Balance the shadow pool at time of mint",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of pool tokens to be minted"
                }
            },
            "getRatio(uint256,uint256)": {
                "details": "Rounds any overflow towards 0. If either parameter is zero, the ratio is 0",
                "params": {
                    "_denominator": "The \"per part\" side of the equation. If this is zero, the ratio is zero",
                    "_numerator": "The \"parts per\" side of the equation. If this is zero, the ratio is zero"
                },
                "returns": {
                    "_0": "the ratio, as an ABDKMathQuad number (IEEE 754 quadruple precision floating point)"
                }
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "details": "Calculates as `balance * amountIn / (tokenSupply + shadowBalance)",
                "params": {
                    "amountIn": "Commitment amount of collateral tokens going into the pool",
                    "balance": "Balance of the pool (no. of underlying collateral tokens in pool)",
                    "shadowBalance": "Balance the shadow pool at time of mint",
                    "tokenSupply": "Total supply of pool tokens"
                },
                "returns": {
                    "_0": "Number of settlement tokens to be withdrawn on a burn"
                }
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "details": "If you try to uncommit AFTER the frontRunningInterval, it should revert.",
                "params": {
                    "frontRunningInterval": "The window of time before a price udpate users can not uncommit or have their commit executed from",
                    "lastPriceTimestamp": "The timestamp of the last price update",
                    "subjectTime": "The timestamp for which you want to calculate if it was beforeFrontRunningInterval",
                    "updateInterval": "The interval between price updates"
                }
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "params": {
                    "a": "The first term",
                    "b": "The second term"
                },
                "returns": {
                    "_0": "The product of a*b as a decimal"
                }
            }
        },
        "title": "Library for various useful (mostly) mathematical functions",
        "version": 1
    },
    "userdoc": {
        "kind": "user",
        "methods": {
            "calculatePriceChange(PoolSwapLibrary.PriceChangeData)": {
                "notice": "Calculates the effect of a price change. This involves calculating how many funds to transfer from the losing pool to the other."
            },
            "compareDecimals(bytes16,bytes16)": {
                "notice": "Compares two decimal numbers"
            },
            "convertDecimalToUInt(bytes16)": {
                "notice": "Converts a raw decimal value to a more readable uint256 value"
            },
            "convertUIntToDecimal(uint256)": {
                "notice": "Converts an integer value to a compatible decimal value"
            },
            "divInt(int256,int256)": {
                "notice": "Divides two integers"
            },
            "fromWad(uint256,uint256)": {
                "notice": "Converts from a WAD to normal value"
            },
            "getBalancesAfterFees(uint256,uint256,uint256)": {
                "notice": "Gets the short and long balances after the keeper rewards have been paid out         Keeper rewards are paid proportionally to the short and long pool"
            },
            "getLossAmount(bytes16,uint256)": {
                "notice": "Calculates the amount to take from the losing pool"
            },
            "getLossMultiplier(bytes16,int8,bytes16)": {
                "notice": "Calculates the loss multiplier to apply to the losing pool. Includes the power leverage"
            },
            "getMintAmount(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of pool tokens to be minted based on existing tokens"
            },
            "getRatio(uint256,uint256)": {
                "notice": "Calculates the ratio between two numbers"
            },
            "getWithdrawAmountOnBurn(uint256,uint256,uint256,uint256)": {
                "notice": "Gets the number of settlement tokens to be withdrawn based on a pool token burn amount"
            },
            "isBeforeFrontRunningInterval(uint256,uint256,uint256,uint256)": {
                "notice": "Returns true if the given timestamp is BEFORE the frontRunningInterval starts,         which is allowed for uncommitment."
            },
            "multiplyDecimalByUInt(bytes16,uint256)": {
                "notice": "Multiplies a decimal and an unsigned integer"
            }
        },
        "version": 1
    },
    "storageLayout": {
        "storage": [],
        "types": null
    }
}
